{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Root","n":1},"1":{"v":"\n# Web Components DOCS\n\nEsta es una documentación de web components basada en el libro *Web Component Essentials* de [[Cory Rylan|https://webcomponent.dev/]]\n","n":0.224}}},{"i":2,"$":{"0":{"v":"Web Components","n":0.707},"1":{"v":"### Qué es un Web Component\nUn Web Component es una pieza aislada de interfaz con una responsabilidad única. Existen muchos frameworks que exponen esta idea de componentes pero las diferencias entre ellos impiden que podamos compartir los componentes en las distintas aplicaciones. La API de Web Components permite solucionar esta fragmentación dando reusabilidad a lo largo de las aplicaciones independientemente del framework utilizado.\n\nLa API de Web Components es una colección de APIs del navegador que en conjunto forman un combo de herramientas altamente reutilizables. \n\nexpect(element.tagName).to.equal('X-DROPDOWN')\n    console.log(element.shadowRoot.innerHTML)","n":0.108}}},{"i":3,"$":{"0":{"v":"High Level Solutions","n":0.577}}},{"i":4,"$":{"0":{"v":"Stencil","n":1},"1":{"v":"Stencil es un compilador de Web Components. Al contrario de [[web-components.high-level-solutions.lit]], Stencil añade un proceso de buildeo para crear los Web Components. Es menos flexible que Lit pero provee una API de mas alto nivel para crear componentes. Aprovecha tecnologías como TypeScript y JSX. Fue creado y mantenido por Ionic, la empresa especializada en native mobile apps y progressive web apps con tecnologias web.\n\nEl kit de UI de Ionic fue construido inicialmente con Angular components, pero recientemente Ionic creo Stencil para desarrollar sus componentes como Web Components. Esto permitio que cualquiera use los componentes de Ionic y que no esten restringidos a aplicaciones Angular.\n\nVamos a crear nuestro [[web-components.examples.dropdown]] con Stencil. Vamos a cubrir los beneficios que provee Stencil como una solucion end to end.\n\n## Stencil CLI\nEs la herramienta de linea de comandos que facilita el creado y buildeo de librerias y progressive apps con Stencil. Nos permite escribir nuestros componentes con JSX y TypeScript. Tambien provee un mecanismo para escribir CSS y Sass en archivos individuales. Por ultimo, tambien provee test unitario incorporado para escribir test automatizados para los componentes. \n\nPrimero necesitamos instalar la CLI\n```bash\nnpm init Stencil\n```\n\nEste comando va a iniciar la Stencil CLI y nos va a generar una prompt para elegir el nombre del proyecto. Nosotros vamos a seleccionar la component library option, es decir una libreria.\nUna vez completado, vamosa  tener el proyecto iniciado para poder empezar a crear nuestros componentes.\n\nVamos a tener un directorio `src/components` donde se va a encontrar un componente único `my-component.tsx`. Stencil se escribe en TypeScript y JSX, si usaste React o Angular esto se va a sentir muy familiar. Se ve como una mezcla entre ambos frameworks.\n\nCreamos el archivo `x-dropdown.tsx` para nuestro componente en el directorio de componentes.\n\n```tsx\n import { Component, Event, EventEmitter, Prop, State, h } from \"@stencil/core\";\n\n @Component({\n    tag: \"x-dropdown\",\n    styleUrl: \"x-dropdown.css\",\n    shadow: true\n })\n export class XDropdown {\n  @Prop() myTitle = 'dropdown';\n  @State() show = false;\n  @Event() showChange: EventEmitter;\n\n  render(){\n    return(\n      <div>\n        <button onClick={() => this.toggle ()}>{this.myTitle}</button>\n        {this.show\n          ? <div class=\"x-dropdown__content\"><slot /></div>\n          : <div></div>\n        }\n      </div>\n    )\n  }\n  toggle(){\n    this.show = !this.show;\n    this.showChange.emit(this.show);\n  }\n }\n```\n![[web-components.high-level-solutions.stencil.decorators]]\n\nDespues de los decoradores encontramos un metodo `render()` que espera que le pasemos una plantilla JSX\n![[web-components.high-level-solutions.stencil.jsx-templates]]\n\nY por ultimo tenemos el metodo `toggle()` que va a invertir nuestra propiedad show y dispara el evento `showChange`\n\nAhora vamos a ver como podemos utilizar nuestro componente dentro de otro componente de Stencil.\n\n![[web-components.high-level-solutions.stencil.component-bindings]]\n\nPor ultimo vamos a buildear nuestra libreria\n\n![[web-components.high-level-solutions.stencil.building]]\n\nStencil es una excelente opcion para crear Web Components ya que nos da la conveniencia de un framework y todas las ventajas de los Web Components.","n":0.049}}},{"i":5,"$":{"0":{"v":"JSX Templates","n":0.707},"1":{"v":"```tsx\n  render(){\n    return(\n      <div>\n        <button onClick={() => this.toggle ()}>{this.myTitle}</button>\n        {this.show\n          ? <div class=\"x-dropdown__content\"><slot /></div>\n          : <div></div>\n        }\n      </div>\n    )\n  }\n```\n\nEn la plantilla podemos escuchar eventos del DOM y disparar llamadas a los metodos. En nuestro ejemplo llamamos el metodo `toggle()` en el `onClick`\n\nPara los renderizados condicionales podemos usar ternarios como en\n```js\nthis.show\n          ? <div class=\"x-dropdown__content\"><slot /></div>\n          : <div></div>\n```\n","n":0.132}}},{"i":6,"$":{"0":{"v":"Decorators","n":1},"1":{"v":"# Decorators\nStencil usa una combinacion de decoradores y JSX para mantener una forma declarativa y sencilla de crear Web Components. \n\n```tsx\n@Component({\n  tag: 'x-dropdown',\n  styleUrl: 'x-dropdown.css',\n  shadow: true\n})\n```\n\nSi usaste Angular, este decorador te parecerá familiar. Los decoradores se compilan en TypeScript y luego en Javascript. Estos permiten a los desarrolladores agregar metadata adicional a clases y propiedades. Stencil los utiliza para ayudarte a crear y compilar tus componentes en un Web Component.\n\nEl decorador `@Component` describe nuestro componente. El `tag` indica cual va a ser el tag de nuestro elemento. El `styleUrl` nos permite definir un archivo separado para los estilos del componente. El `shadow` nos permite decirle a Stencil si queremos que active o desactive el [[web-components.Apis.shadow-dom]] para nuestro componente.\n\nTambien tenemos decoradores en nuestras propiedades: \n\n```tsx\n@Prop() title = 'dropdown';\n@State() show = false;\n@Event() showChange: EventEmitter;\n```\n\nCada decorador agrega un comportamiento a nuestro componente. El primero decorador `@Prop` nos permite definir propiedades publicas para que otros pasen data. En este caso tenemos el `title` para setear el texto del boton.\n\nEl decorador `@State` nos permite indicarle a Stencil que propiedades, cuando sean actualizadas, deberian disparar un re-render. En nuestro caso, siempre que el boton se clickee, actualizamos al propiedad `show`, y por el `@State` el template se vuelve a renderizar.\n\nEl decorador `@Event` nos permite crear [[Custom Events|web-components.communication.events]] para nuestro componente. Aplicando el `@Event` podemos llamar a `this.showChange.emit(this.show)` para disparar nuestro evento `showChange`. El nombre de la propiedad es el nombre del evento emitido.","n":0.065}}},{"i":7,"$":{"0":{"v":"Component Bindings","n":0.707},"1":{"v":"\nEn el componente MYComponent que creo la CLI de Stencil vamos a usar nuestro XDropdown.\n\n```tsx\n//my-component.tsx\nimport { Component, h } from '@stencil/core';\n\n@Component({\n  tag: 'my-component',\n  styleUrl: 'my-component.css',\n  shadow: true,\n})\nexport class MyComponent {\n  private myTitle = 'StencilJS';\n  render() {\n    return (\n      <div>\n        Hello World, I am web component built with stencil\n        <div>\n          <x-dropdown title={this.myTitle} onShowChange={(e) => this.log(e)}>\n            Hello  <b>from Stencil</b> Dropdown!\n          </x-dropdown>\n        </div>\n      </div>\n    );\n  }\n  private log(e: any){\n    console.log(e);\n  }\n}\n```\n![example](image-27.png)\n\n","n":0.121}}},{"i":8,"$":{"0":{"v":"Building","n":1},"1":{"v":"\nStencil puede buildear aplicaciones enteras, pero esta diseñada para permitir escribir y publicar rapidamente Web Components. Para crear los Web Components, escribimos en el root del proyecto el siguiente comando\n\n```bash\nnpm run build\n```\n\nEste comando va a compilar nuestros componentes Stencil a Web Components planos que podremos usar en cualquier lado. Podemos configurar el archivo `stencil.config.js` para especificar a donde se compilan los componentes. Podemos encontrar mas opciones sobre como distribuir nuestros componentes en la documentacion de stencil [[https://stenciljs.com/docs/distribution]]\n\n","n":0.114}}},{"i":9,"$":{"0":{"v":"Lit","n":1},"1":{"v":"\nLit es una libreria liviana que facilita la escritura y uso de Web Components. Fue creado y mantenido por el equipo Polymer en Google. No es la librería de Polymer Web Component sino que es una nueva individual. Vamos a convertir nuestro [[web-components.examples.dropdown]] en un Lit Element a medida que avanzamos en la sección.\n\nEmpecemos viendo las [[web-components.high-level-solutions.lit.template-strings]] de Lit.\n\nPodemos agregar tambien [[Lit Event Listeners|web-components.high-level-solutions.lit.template-event-listeners]] a nuestras templates.\n\nCon estos cambios nuestro dropdown todavía no va a comportarse como deseamos, tenemos que utilizar las [[web-components.high-level-solutions.lit.properties-and-decorators]]\n\nEn Lit los [[Custom Events|web-components.communication.events]] se utilizan de la misma manera que en los Web Components.\n\n```js\nimport {LitElement, html} from 'lit';\nclass XDropdown extends LitElement{\n  static get properties(){\n    return{\n      visible: {type: Number},\n      title: {type: String}\n    }\n  }\n  constructor(){\n    super();\n    this.visible = false;\n    this.title = 'dropdown';\n  }\n  render(){\n    return html`\n      <style>\n        .dropdown div{\n          border: 1px solid #ccc;\n          padding; 12px;\n        }\n      </style> \n      <div class=dropdown>\n        <button @click=\"${() => this.toggle()}\">${this.title}</button>\n        ${this.visible ? \n          html`\n            <div>\n              <slot></slot>\n            </div>\n          ` : ''}\n      </div>\n    `\n  }\n  toggle(){\n    this.visible = !this.visible\n    this.dispatchEvent(new CustomEvent('visibleChange', {detail: this.visible}))\n  }\n}\n```\nAhora que tenemos nuestro componente completo, con los eventos configurados, podemos interactuar con el como si se tratara de cualquier otro web component\n```js\n//index.js\nconst dropdown = document.querySelector('x-dropdown');\ndropdown.title = 'custom dropdown';\ndropdown.addEventListener('visibleChange', (e) => {console.log(e)})\n```\n#\nAhora veremos como [[Bindear a otros Web Components con Lit|web-components.high-level-solutions.lit.binding-components]]","n":0.069}}},{"i":10,"$":{"0":{"v":"Examples","n":1}}},{"i":11,"$":{"0":{"v":"Unit Testing","n":0.707},"1":{"v":"El unit testing puede mejor considerablemente la calidad de nuestro codigo. Nos aseguran que el codigo que estamos cambiando sigue siendo funcional bajo unos estandares. Como los Web Components corren nativamente en el navegador, podemos correr unit test usando cualquier framework de Javascript.\n\nPara este caso vamos a usar el componente dropdown que desarrollamos en [[Lit|web-components.high-level-solutions.lit]]. \n\nLos proyectos [[Open Web Components | https://open-wc.org/]] y [[Modern Web | https://modern-web.dev/]] proveen una suit de utilidades para el testeo de Web Components y Web Components construidos con Lit.\n\n## Setting up the Test Runner\n\nCon nuestro dropdown, podemos escribir distintos casos de test pero primero vamos a hacer la configuración incial de nuestra suite de tests. Para correr nuestros test vamos a necesitar un `test runner`. Vamos a usar `@web/test-runner`  para correrlos nativamente en el navegador.\nTambien vamos a necesitar una libreria de testeo para correr aserciones para nuestor codigo. `@open-wc` tiene unas muy buenas opciones para esto.\n\n```json\n{\n  \"name\": \"14-unit-test\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Basic unit testing example\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"web-dev-server --node-resolve --open\",\n    \"clean\": \"find . -name 'node_modules' -exec rm -rf '{}' +\",\n    \"test\": \"web-test-runner ./**/*.spec.ts --node-resolve\",\n    \"test:watch\": \"web-test-runner ./**/*.spec.ts --node-resolve --watch\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"lit\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"@open-wc/testing\": \"^2.5.33\",\n    \"@web/dev-server\": \"^0.1.24\",\n    \"@web/dev-server-esbuild\": \"^0.2.14\",\n    \"@web/test-runner\": \"^0.13.18\",\n    \"@web/test-runner-puppeteer\": \"^0.13.1\",\n    \"typescript\": \"^4.4.3\"\n  }\n}\n```\n\nEl paquete `@open-wc` nos provee de utilidades para test. `@web/dev-server` y `@web/test-server` nos permite correr localhost y test runners. `@web/dev-server-esbuild` y `typescript` nos permitiran escribir nuestros componentes y nuestros unit test en typescript. \n\nVamos a ver el `web-test-runner.config.mjs` en el root del proyecto.\n\n```js\nimport {esbuildPlugin} from '@web/dev-server-esbuild';\nimport {puppeteerLauncher} from '@web/test-runner-puppeteer';\n\nexport default {\n  nodeResolve: true,\n  rootDir: './',\n  plugins: [esbuildPlugin({ts: true, target: 'esnext'})],\n  browsers: [puppeteerLauncher({\n    launchOptions: {\n      executablePath: '/usr/bin/chromium-browser',\n    }\n  })],\n}\n```\nEsta configuracion nos permite configurar y agregar plugins a nuestros test. Como usamos Lit y Typescript podemos usar el plugin de esbuild para compilar nuestro codigo.\n\n## Unit Test Structure\n\nVamos a iniciar con nuestro componente para testear lo que creamos en otras secciones\n\n```ts\nimport { LitElement, html, css } from 'lit';\nimport { property } from 'lit/decorators/property.js';\nimport { customElement } from 'lit/decorators/custom-element.js';\n\n@customElement('x-dropdown')\nexport class XDropdown extends LitElement {\n  @property({ type: Boolean }) open = false;\n  @property({ type: String }) title = 'dropdown';\n\n  static styles = [css`\n    div {\n      border: 1px solid #ccc;\n      padding: 12px;\n    }\n  `];\n\n  render() {\n    return html`\n      <button @click=${() => this.toggle()}>${this.title}</button>\n      ${this.open  ? html`<div><slot></slot></div>` : '' }\n    `;\n  }\n\n  private toggle() {\n    this.open = !this.open;\n    this.dispatchEvent(new CustomEvent('openChange', { detail: this.open }));\n  }\n}\n```\n\nEn nuestro archivo `dropdown.spec.ts` escribimos la configuracion basica de nuestro test\n```ts\nimport {expect, fixture, html} from \"@open-wc/testing\";\nimport {Dropdown} from \"./dropdown\";\nimport \"./dropdown\";\n\ndescribe(\"x-dropdown\", () => {\n  it('creates component', async () => {\n    const el = await fixture(html`<x-dropdown></x-dropdown>`);\n    expect(el.tagName).to.equal(\"X-DROPDOWN\");\n  })\n});\n```\nEl paquete `@open-wc/testing` nos provee de utilizades para testear componentes de Lit. Los test estan organizados utilizando `describe` y `it` en bloques de funciones. La funcion `describe` define que es lo que estamos testeando, y la funcion `it` corre nuestro `expect` para cada comportamiento que querramos testear.\n\nPara nuestro primer ejemplo, nuestro test va a chequear que nuestro componente se haya creado correctamente. Como nuestro componente esta hecho con `Lit`, la template se va a renderizar de manera asincrona. Podemos usa `fixture` para esperar hasta que el componente haya sido completamente renderizado y asi poder obtener una referencia a el. Esto asegura que el componente fue renderizado y esta disponible para que nosotros accedamos dentro de nuestro test.\n\n## Primer Test Unitario\n\nPara nuestro primer test, podemos chequear que cuando la propiedad `open` sea `falsa`, el dropdown este oculto con `hidden`. Por el contrario que tambien este visible cuando `open=true`.\n\n```ts\nimport {expect, fixture, html} from \"@open-wc/testing\";\nimport {Dropdown} from \"./dropdown\";\nimport \"./dropdown\";\n\ndescribe(\"x-dropdown\", () => {\n  it('creates component', async () => {\n    const el = await fixture(html`<x-dropdown></x-dropdown>`);\n    expect(el.tagName).to.equal(\"X-DROPDOWN\");\n  })\n  it('should open and close dropdown when open property is set', async () => {\n    const element = await fixture<Dropdown>(html`<x-dropdown></x-dropdown>`);\n    await element.updateComplete;\n    expect(element.open).to.equal(false);\n    expect(element.shadowRoot.querySelector('div')).to.equal(null);\n  })\n});\n```\n\nUsando `await` y `fixture` podemos esperar a que nuestro componente este completamente renderizado. Luego esperamos que `open=false`, podemos hacerle una query a nuestro `shadowRoot` para asegurarnos de que el `div` no se renderizo.\n\nPara correr los test, podemos usar el siguiente comando\n```bash\nwebn-test-runner ./**/*.spec.ts --node-resolve\n```\nO nuestro script que ya configuramos en el `package.json`\n```bash\nnpm run test\n```\n\nSi todo esta bien instalado deberiamos ver el siguiente resultado en nuestra consola\n![Alt text](image-29.png)\n\nAhora mejoremos el test para ver si cuando el `open` es `true` nuestro dropdown se muestra como es esperado.\n\n```ts\nimport { expect, fixture, html, elementUpdated } from '@open-wc/testing';\nimport { XDropdown } from './dropdown.element.js';\nimport './dropdown.element.js';\n\ndescribe('x-dropdown', () => {\n  it('creates component', async () => {\n    const element = await fixture(html`<x-dropdown></x-dropdown> `);\n  });\n\n  it('should open and close dropdown when open property is set', async () => {\n    const element = await fixture<XDropdown>(html`<x-dropdown></x-dropdown> `);\n    expect(element.open).to.equal(false);\n    expect(element.shadowRoot.querySelector('div')).to.equal(null);\n\n    element.open = true;\n    await elementUpdated(element);\n    console.log(element.shadowRoot.innerHTML)\n    expect(element.shadowRoot.querySelector('div').tagName).to.equal('DIV');\n  });\n\n  it('should open and close dropdown when button is clicked', async () => {\n    const element = await fixture<XDropdown>(html`<x-dropdown></x-dropdown> `);\n    await element.updateComplete;\n\n    element.shadowRoot.querySelector('button').click();\n    await element.updateComplete;\n    expect(element.open).to.equal(true);\n    expect(element.shadowRoot.querySelector('div').tagName).to.equal('DIV');\n\n    element.shadowRoot.querySelector('button').click();\n    await element.updateComplete;\n    expect(element.open).to.equal(false);\n    expect(element.shadowRoot.querySelector('div')).to.equal(null);\n  });\n});\n\n```\n\nCon esto al correr `npm run test` ya podremos ver que nuestros tests pasan correctamente y hemos terminado con el unit testing.","n":0.035}}},{"i":12,"$":{"0":{"v":"Todo App","n":0.707},"1":{"v":"\nVamos a construir una TodoApp como ejemplo de como se construye una web app con Web Components. Esta App podra crear, borrar y actualizar una todo list usando Lit y el local storage. Esto tambien reforzara buenas practicas para la arquitectura de componentes.\n\n![Alt text](image-28.png)\n\nVamos a usar Lit para los Web Component templates. Tambien vamos a usar Webpack para compilar nuestra app con TypeScript.\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Todo App with LIt</title>\n  <link rel=\"stylesheet\" href=\"./css/index.css\">\n</head>\n<body>\n  <main>\n    <x-app></x-app>\n  </main>\n  <script src=\"../dist/bundle.js\"></script>\n</body>\n</html>\n```\n\nComo todas las aplicaciones de componentes vamos a tener un componente root. Nuestro componente va a estar empaquetado en un archivo js unico con Webpack y lo incluiremos al final del archivo con un script.\n\n```ts\n//app.ts\nimport { LitElement, html } from \"lit\";\nimport {customElement} from \"lit/decorators.js\";\n\n@customElement(\"x-app\")\nexport class Todo extends LitElement {\n  constructor(){\n    super()\n  }\n  render(){\n    return html`\n     <header>\n      <h1>Todos</h1>\n     </header>\n     <main>\n      <x-todos></x-todos>\n     </main>\n     <footer>\n      2018\n     </footer>\n    `\n  }\n}\n```\nNuestro componente root define la estructura basica de nuestra aplicacion. SI nuestra app tuviera un header mas elaborado para la navegacion, tendriamos que incluirlo aqui. \n\nEn el main tenemos un componente `x-todos`, lo importamos al inicio del archivo. Este componente sera el responsable de manejar los todos de nuestra app.\n\nNotemos que en este caso estamos registrando nuestro componente con el decorador `@customElement('x-app')` eliminando boilerplate.\n\n### Todos Data Service\n\nAntes de saltar al componente `x-todos` vamos a hacer un una clase servicio que se encargue de guardar y obtener nuestros todos del local storage. Vamos a crear un archio `todo.service.ts` que sera responsable de los cambios en nuestros todos y de persistirlos en el local storage.\n\n```ts\n//todos.service.ts\nimport {Todo} from './interfaces';\n\nexport class TodoService {\n  getTodos(){\n    const todos: Todo[] = JSON.parse(localStorage.getItem('todos'))\n    return todos ? todos : []\n  }\n  updateTodo(todo: Todo, index: number){\n    const todos =  this.getTodos();\n    todos[index] = todo;\n    return this.saveTodos(todos)\n  }\n  deleteTodo(todo: Todo){\n    const todos = this.getTodos();\n    const updateTodos = todos.filter(t => t.value !== todo.value);\n    return this.saveTodos(updateTodos);\n  }\n  createTodo(value: string){\n    const todos = this.getTodos();\n    const updatedTodos = [...todos, {value, completed: false}]\n    return this.saveTodos(updatedTodos)\n  }\n  private saveTodos(todos: Todo[]){\n    localStorage.setItem('todos', JSON.stringify(todos))\n    return todos;\n  }\n}\n```\n```ts\n//interfaces.ts\nexport interface Todo {\n  value: string;\n  completed: boolean;\n}\n```\n\nNuestro servicio abstrae toda la logica de guardado y actualizacion en una sola clase. De esta manera, podemos mantener nuestros componentes ocupados en solo renderizar la data. La mejor practica en Web Apps es tener una **clara separacion de la logica de datos y la logica de render** entre componentes. Esta separacion permite que la logica y los componentes puedan testearse de manera unitaria mas facilmente.\n\n### Todos List\n\nEl componente `x-todos` se va a comunicar directamente con nuestro servicio para guardar y actualizar la data.\n\n```ts\nimport { LitElement, html } from \"lit\";\nimport {customElement, property} from 'lit/decorators.js'\nimport { TodoService } from \"./todo.service\";\nimport { Todo } from \"./interfaces\";\nimport './todo-item'\n\n@customElement('x-todos')\nexport class Todos extends LitElement {\n  @property({type: Array})\n  todos: Todo[] = [];\n  todoService = new TodoService();\n\n  constructor(){\n    super()\n    this.todos = this.todoService.getTodos();\n  }\n}\n```\n\nCreamos el componente con una propiedad `todos` usando el decorador `@property`. Tambien creamos una instancia de nuestro `TodoService` para usar dentro de nuestro componente. En el constructor asiganmos los todos que esten en local storage a nuestras `todos`.\n\nAhora agregamos el template y los metodos de la clase\n\n```ts\nimport { LitElement, html } from \"lit\";\nimport { customElement, property } from 'lit/decorators.js'\nimport { TodoService } from \"./todo.service\";\nimport { Todo } from \"./interfaces\";\nimport './todo-item'\n\n@customElement('x-todos')\nexport class Todos extends LitElement {\n  @property({ type: Array })\n  todos: Todo[] = [];\n  todoService = new TodoService();\n\n  constructor() {\n    super()\n    this.todos = this.todoService.getTodos();\n  }\n  render() {\n    return html`\n      <form @submit=${(e: Event) => this.createTodo(e)}>\n        <input type=\"text\" placeholder=\"Add todo\" aria-label=\"Add todo\" />\n        <button>Add</button>\n      </form>\n      <ul>\n        ${this.todos.map((todo, index) => html`\n        <li>\n          <x-todo-item \n            .todo=${todo} \n            @update=\"${(e: CustomEvent) => this.updateTodo(e.detail, index)}\" \n            @delete=\"${(e: CustomEvent) => this.deleteTodo(e.detail)}\">\n          </x-todo-item>\n        </li>\n      `)}\n      </ul>\n    `\n  }\n  createTodo(e: Event) { \n    e.preventDefault();\n    const target = e.target as HTMLFormElement;\n    const input = target.querySelector('input');\n    if (input instanceof HTMLFormElement) {\n      const value = input.value;\n      if (!value) return\n      this.todos = this.todoService.createTodo(\n        value\n      )\n      input.value = '';\n    }\n   }\n   updateTodo(todo: Todo, index: number){\n      this.todos = this.todoService.updateTodo(\n        todo,\n        index\n      )\n   }\n    deleteTodo (todo: Todo){\n      this.todos = this.todoService.deleteTodo(\n        todo\n      )\n    }\n}\n```\n\nLa primer parte de nuestro template define un HTML form para crear los todos. Usando el form podemos disparar el evento `submit` con un boton. En el submit llamamos a `createTodo()` que es un metodo interno de la clase.\n\nLa segunda parte del template renderiza una lista de todos. Cada todo con un `x-todo-item` que contiene la logica para cuando un usuario clickea en done, delete or update. Cuando estas acciones ocurren, el `x-todo-item` emite un `@update` o `@delete` para que nuestra lista pueda actualizar los todos con el servicio.\n\nNuestro `x-todo-item` es un componente que solo renderea. Toma un objeto todo por bindeo en la propiedad `.todo`. Si algo cambia, emite el evento necesario. Este aislamiento permite que el componente `x-todo-item` sea mas generico y reutilizable. \n\n### Todo Item\n\nEl componente `x-todo-item` es responsable de renderizar un solo todo y emitir los eventos de este item.\n\n```ts\nimport {LitElement, html} from 'lit';\nimport {customElement, property} from 'lit/decorators.js';\nimport { Todo } from './interfaces';\n\n@customElement('x-todo-item')\nexport class XTodoItem extends LitElement {\n  @property({type: Object})\n  todo: Todo\n\n  @property({type: Boolean})\n  editing = false;\n\n  render(){\n    return html`\n      <style>\n        .completed{\n          text-decoration: line-through;\n        }\n        span{\n          padding: 0 12px;\n        }\n        form {\n          display: inline-block;\n        }\n      </style>\n      <button @click=\"${() => this.completeTodo()}\" aria-label=\"mark done\">âœ“</button>\n      ${this.editing \n        ? html`\n          <form @submit=\"${(e: Event) => this.editTodo(e)}\">\n            <input type=\"text\" .value=\"${this.todo.value}\" aria-label=\"Edit todo\" placeholder=\"Todo\"/>\n          </form>\n        ` \n        : html`\n          <span class=\"${this.todo.completed ? 'completed' : ''}\" @dblclick=\"${() => this.toggleForm()}\">${this.todo.value}</span>\n        `}\n        <button @click=\"${() => this.deleteTodo()}\" aria-label=\"delete todo\">x</button>\n    `\n  }\n\n  completeTodo(){\n    this.todo = {...this.todo, completed: !this.todo.completed}\n    this.emitUpdate();\n  }\n  editTodo(event: Event){\n    event.preventDefault();\n    const target = event.target as HTMLFormElement;\n    const input = target.querySelector('input');\n    if (input instanceof HTMLInputElement) {\n      const value = input.value;\n      if (!value) return;\n      this.todo.value = value;\n      this.toggleForm();\n      this.emitUpdate();\n    }\n  }\n  toggleForm(){\n    this.editing = !this.editing;\n  }\n  deleteTodo(){\n    this.dispatchEvent(new CustomEvent('delete', {detail: this.todo}))\n  }\n  private emitUpdate(){\n    this.dispatchEvent(new CustomEvent('update', {detail: this.todo}))\n  }\n}\n```\n\nLos metodos en el todo item actualizan nuestro objeto todo y emite la actualizacion.\n","n":0.032}}},{"i":13,"$":{"0":{"v":"Template Strings","n":0.707},"1":{"v":"\nLit incluye una librería de templating construida por encima de las templated literals de Javascript, que son las que construimos entre backsticks: `\n\nLas template literals nos permiten crear templates en el navegador, Lit tambien incluye una clase base que facilita la creacion de Web Components.\n\nEn este ejemplo tomaremos el [[web-components.examples.dropdown]] y lo convertiremos usando Lit. \n\n```js\nimport {LitElement, html} from 'lit';\nclass XDropdown extends LitElement{\n  render(){\n    return html`\n      Hello from Lit \n    `\n  }\n}\n```\n\nImportamos la clase `LitElement` del paquete de `lit` para crear nuestro componente. Lit espera que se implemente un metodo `render`. Este metodo retorna una template con nuestro componente. Nuestra template es creada usando la [[Tagged Template Literals | https://www.freecodecamp.org/news/a-quick-introduction-to-tagged-template-literals-2a07fd54bc1d/]] `html` del paquete de lit. `html` nos provee mas funcionalidades de templating que veremos mas adelante.\n\n","n":0.089}}},{"i":14,"$":{"0":{"v":"Template Event Listeners","n":0.577},"1":{"v":"```js\nimport {LitElement, html} from 'lit';\nclass XDropdown extends LitElement{\n  render(){\n    return html`\n      <style>\n        .dropdown div{\n          border: 1px solid #ccc;\n          padding; 12px;\n        }\n      </style> \n      <div class=dropdown>\n        <button @click=\"${() => this.toggle()}\">${this.title}</button>\n        ${this.visible ? \n          html`\n            <div>\n              <slot></slot>\n            </div>\n          ` : ''}\n      </div>\n    `\n  }\n  toggle(){\n    this.visible = !this.visible\n  }\n}\n```\n\nEn esta template tenemos un boton y un slot element que se va a mostrar y ocultar dinamicamente. Lit crea automaticamente la template usando la `HTML Template API` y el [[web-components.Apis.shadow-dom]]. Usar estas apis nos permitara lograr la [[web-components.styling.css-encapsulation]].\n\nLit tiene una API declarativa para escuchar eventos. En el boton agregamos `@click=\"${() => this.toggle}\"`, usando el `@` podemos bindear eventos y reaccionar a ellos.","n":0.096}}},{"i":15,"$":{"0":{"v":"Properties and Decorators","n":0.577},"1":{"v":"Para que Lit renderice nuestro componente correctamente cuando las propiedades cambian, debemos decirle que propiedades pueden cambiar explicitamente. Para esto tenemos 2 opciones, la primera es declarar nosotros la lista de propiedades que pueden ser seteadas en el componente\n\n```js\nimport {LitElement, html} from 'lit';\nclass XDropdown extends LitElement{\n  static get properties(){\n    return{\n      visible: {type: Number},\n      title: {type: String}\n    }\n  }\n  constructor(){\n    super();\n    this.visible = false;\n    this.title = 'dropdown';\n  }\n  render(){\n    return html`\n      <style>\n        .dropdown div{\n          border: 1px solid #ccc;\n          padding; 12px;\n        }\n      </style> \n      <div class=dropdown>\n        <button @click=\"${() => this.toggle()}\">${this.title}</button>\n        ${this.visible ? \n          html`\n            <div>\n              <slot></slot>\n            </div>\n          ` : ''}\n      </div>\n    `\n  }\n  toggle(){\n    this.visible = !this.visible\n  }\n}\n```\n\nEl get estatico `static get properties()` le permite a LIt observar cuando las propiedades se setean y si deberia re-renderizar el componente. La otra API opcional es que podemos usar decoradores experimentales e inicializadores de propiedades en vez de usar una lista estatica de propiedades. Los decoradores y los inicializadores de propiedades son funcionalidades propuestas para Javascript, pero que todavia no estan disponibles. Si usamos Babel o Typescrit, podemos usar el siguiente codigo\n```ts\nimport {LitElement, html} from 'lit';\nimport {property} from 'lit/decorators.js'\nclass XDropdown extends LitElement{\n  @property()\n  visible = false;\n\n  @property()\n  title = 'dropdown';\n\n  render(){\n    return html`\n      <style>\n        .dropdown div{\n          border: 1px solid #ccc;\n          padding; 12px;\n        }\n      </style> \n      <div class=dropdown>\n        <button @click=\"${() => this.toggle()}\">${this.title}</button>\n        ${this.visible ? \n          html`\n            <div>\n              <slot></slot>\n            </div>\n          ` : ''}\n      </div>\n    `\n  }\n  toggle(){\n    this.visible = !this.visible\n  }\n}\n```\n\nUsando decoradores tenemos una sintaxis mas declarativa, la contra es que necesitamos un paso extra en el buildeo del proyecto para transpilar este codigo.","n":0.062}}},{"i":16,"$":{"0":{"v":"Custom Events","n":0.707}}},{"i":17,"$":{"0":{"v":"Binding Components","n":0.707},"1":{"v":"Lit puede usarse para interactuar con otros Web Components existentes en nuestras aplicaciones. En el ejemplo anterior creamos de forma imperativa una referencia y un event listener para nuestro dropdown. \n\nPrimero crearemos un componente raiz en el nivel mas alto.\n\n```js\n//x-app.js\nimport {LitElement, html} from 'lit';\nimport {property} from 'lit/decorators.js'\nimport 'dropdown'\n\nclass XApp extends LitElement{\n  render(){\n    return html`\n      <x-dropdown>\n        Hello from Lit!\n      </x-dropdown>\n    `\n  }\n}\ncustomElements.define('x-app', XApp)\n```\n\nCon este componente podemos usar el binding declarativo de Lit para setear propiedades y escuchar a eventos\n\n```js\n//x-app.js\nimport {LitElement, html} from 'lit';\nimport {property} from 'lit/decorators.js'\nimport 'dropdown'\n\nclass XApp extends LitElement{\n  render(){\n    return html`\n      <x-dropdown @visibleChange=${(e) => this.log(e)}>\n        Hello from Lit!\n      </x-dropdown>\n    `\n  }\n  log(e){\n    console.log(e)\n  }\n}\ncustomElements.define('x-app', XApp)\n```\n\nUsamos el `@` para escuchar al evento. Esto funciona no solo con eventos nativos del DOM sino tambien con eventos custom como `visibleChange`. Podemos hacer lo mismo con las propiedades:\n```js\n//x-app.js\nimport {LitElement, html} from 'lit';\nimport {property} from 'lit/decorators.js'\nimport 'dropdown'\n\nclass XApp extends LitElement{\n  constructor(){\n    super();\n    this.customTitle = 'Custom Title!'\n  }\n  render(){\n    return html`\n      <x-dropdown @visibleChange=${(e) => this.log(e)} .title=${this.customTitle}>\n        Hello from Lit!\n      </x-dropdown>\n    `\n  }\n  log(e){\n    console.log(e)\n  }\n}\ncustomElements.define('x-app', XApp)\n```\n\nEn lit usamos el `.` para bindear propiedades.","n":0.075}}},{"i":18,"$":{"0":{"v":"Extra Tools","n":0.707}}},{"i":19,"$":{"0":{"v":"Webpack","n":1},"1":{"v":"Webpack es un empaquetador de modulos y dpeendencias para aplicaciones web. Facilita el tomar todas las dependencias de nuestro proyecto y enpaquetarlas en un solo archivo facil de distribuir en un ambiente productivo.\nWebpack puede empaquetar distintos tipos de assets por medio de plugins. Pro ejemplo si queremos usar un preprocesador de CSS como Less o Sass, podríamos usar un plugin de webpack para observar estos archivos y compilarlos. En este caso usaremos Babel para compilar y empaquetar nuestro codigo ES2015 a ES5.\n\nPrimero creamos el webpack.config.js\n\n```js\nvar path = require('path');\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'index.js',\n    library: 'webComponent',\n    libraryTarget: 'umd'\n  }\n};\n```\n\nEsta es la configuración mínima de Webpack. El ```entry``` es el main de nuestra librería. Desde ese archivo Webpack empezará y resolverá cualquier dependencia (imporst). El ```output``` define donde se va a generar el codigo compilado. También define su nombre y que tipo de archivo JavaScript va a ser.\n\nAhora podemos correr el comando\n\n```bash\nnpm run build\n```\n\nSi vamos a la carpeta dist vamos a ver un ```index.js``` compilado a ES5 que será compatible con IE11.","n":0.075}}},{"i":20,"$":{"0":{"v":"Examples","n":1}}},{"i":21,"$":{"0":{"v":"Dropdown","n":1},"1":{"v":"Tomaremos lo que aprendimos de las APIS [[wc.Apiscustom-elements]], [[wc.Apistemplate]], [[web-components.Apis.shadow-dom]] y [[web-components.Apis.content-slot]] para crear un simple componente dropdown.\n\nPrimero definimos nuestro custom element en un archivo js\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <button>Dropdown</button>\n  <div>\n    <slot></slot>\n  </div>\n`;\n\nclass XDropdown extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-dropdown', XDropdown);\n```\n\nNuestro componente tiene un boton para activar o desactivar nuestro contenido. También usamos la Content Slot API para pasar el contenido fácilmente al componente.\nDebemos agregar algunas referencias del DOM al componente para acceder a nuestro boton y contenido.\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <button>Dropdown</button>\n  <div>\n    <slot></slot>\n  </div>\n`;\n\nclass XDropdown extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n\n  connectedCallback() {\n    // El shadow root también nos da acceso al inner template del componente\n    this.button = this.shadowRoot.querySelector('button');\n    this.button.addEventListener('click', () => this.toggle());\n    // Seteamos el contenido del dropdown a hidden\n    this.content = this.shadowRoot.querySelector('div');\n    this.content.style.display = 'none';\n  }\n\n  toggle() {\n    const show = this.content.style.display === 'block';\n    this.content.style.display = show ? 'none' : 'block';\n  }\n}\n\ncustomElements.define('x-dropdown', XDropdown);\n```\n\nEn el constructor podemos hacerle una query a nuestro template por medio del shadow root. Creamos referencias al boton y al contenido para poder manipularlos dinamicamente. \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-dropdown>\n    Hello World!\n  </x-dropdown>\n  <script type=\"module\" src=\"x-dropdown.js\"></script>\n</body>\n</html>\n```\n\n### Mejoramos nuestro componente\nGracias a las [[web-components.communication.js-properties]] y [[web-components.communication.events]] podemos mejorar nuestro componente y agregarle nuevas funcionalidades. Primero queremos que el texto del botón sea dinámico. Segundo, queremos crear un custom event listener para saber cuando un usuario ha abierto o cerrado el dropdown.\n\n```js\n// x-dropdown.js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <button>Dropdown</button>\n  <div>\n    <slot></slot>\n  </div>\n`;\n\nclass XDropdown extends HTMLElement {\n  get title(){\n    return this._title\n  }\n  set title(value){\n    this._title = value;\n    this.button.innerText = this._title;\n  }\n  constructor() {\n    super();\n    this._title= 'Dropdown';\n    this.show= false;\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n\n  connectedCallback() {\n    this.button = this.shadowRoot.querySelector('button');\n    this.button.innerText = this.title;\n    this.button.addEventListener('click', () => this.toggle());\n    this.content = this.shadowRoot.querySelector('div');\n    this.content.style.display = 'none';\n  }\n\n  toggle() {\n    this.show = !this.show;\n    this.content.style.display = this.show ? 'block' : 'none';\n  }\n}\n\ncustomElements.define('x-dropdown', XDropdown);\n```\n\n```js\n// index.js\nimport './x-dropdown.js'\n\nconst dropdown = document.querySelector('x-dropdown');\n\ndropdown.title = 'Custom Title'\nsetTimeout(() => {\n  dropdown.title = 'New Title'\n}, 3000)\n```\n\nEstablecemos el titulo como *Custom Title* y generamos un timeout para que en 3 segundos cambie a *New Title* dinámicamente.\n\nCon esto logramos pasar la data a nuestro componente via prop y este actualizo su plantilla dinámicamente. Ahora vamos por el evento.\n\n```js\n// x-dropdown.js\n//...inicio componente\n  toggle() {\n    this.show = !this.show;\n    this.content.style.display = this.show ? 'block' : 'none';\n    // despacha el evento show para que otros lo escuchen\n    this.dispatchEvent(new CustomEvent('show', { detail: `El componente esta ${this.show ? 'Visible' : 'Oculto'}` }));\n  }\n//...fin componente\n\n```\n```js\n//index.js\nimport './x-dropdown.js'\n\nconst dropdown = document.querySelector('x-dropdown');\n\ndropdown.title = 'Custom Title'\nsetTimeout(() => {\n  dropdown.title = 'New Title'\n}, 3000)\n\ndropdown.addEventListener('show', (e) => {\n  console.log(e)\n})\n\n```\n![Alt text](image-10.png)\n\nYa estamos escuchando nuestro evento show y podemos reaccionar a el.\n\n### Mejoremos nuestro componente con custom attributes\nDespués de aprender sobre los [[web-components.communication.custom-attributes]] podemos seguir mejorando nuestro componente dropdown.\n\n\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <button></button>\n  <div>\n    <slot></slot>\n  </div>\n`;\n\nclass XDropdown extends HTMLElement {\n  static get observedAttributes() {\n    return ['title'];\n  }\n  get title(){\n    return this._title\n  }\n  set title(value){\n    this._title = value;\n    this.button.innerText = this._title;\n  }\n  constructor() {\n    super();\n    this._title= 'Dropdown';\n    this.show= false;\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === 'title') {\n      this.title = newValue;\n    }\n  }\n\n  connectedCallback() {\n    this.button = this.shadowRoot.querySelector('button');\n    this.button.innerText = this.title;\n    this.button.addEventListener('click', () => this.toggle());\n    this.content = this.shadowRoot.querySelector('div');\n    this.content.style.display = 'none';\n  }\n\n  toggle() {\n    this.show = !this.show;\n    this.content.style.display = this.show ? 'block' : 'none';\n    // despacha el evento show para que otros lo escuchen\n    this.dispatchEvent(new CustomEvent('show', { detail: `El componente esta ${this.show ? 'Visible' : 'Oculto'}` }));\n  }\n}\n\ncustomElements.define('x-dropdown', XDropdown);\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-dropdown title=\"Nuevo Titulo desde html\">\n    Hello World!\n  </x-dropdown>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n\n![Alt text](image-13.png)","n":0.041}}},{"i":22,"$":{"0":{"v":"Apis","n":1}}},{"i":23,"$":{"0":{"v":"template","n":1},"1":{"v":"\nLa API de Template provee muchas características de bajo nivel que se necesitan para construir componentes de UI. Esta API no soporta muchas de las características a las que estamos acostumbrados en los frameworks, como los bucles o condicionales.\n\nMuchas de las APIs de los Web Componentes son de bajo nivel a propósito para permitir flexibilidad y que cada uno pueda construir lo que necesite sobre ellas.\n\nEsta API nos permite crear plantillas neutras en nuestros componentes. El navegador **ignora todo el código que se escriba dentro de esta etiqueta**.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <template>\n    <h1>No voy a renderizarme</h1>\n    <script>\n      alert('no voy a alertar');\n    </script>\n  </template>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\nPodemos ver que el codigo no se renderiza aunque si está en el html dentro de un ```#document-fragment```\n![Alt text](image-3.png)\n\nA continuación podemos clonar la plantilla con js, manipularla para luego finalmente renderizarla.\n\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `<p>Hola desde template</p>`;\n\nclass XComponent extends HTMLElement {\n  constructor() {\n    super();\n    this.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nDe esta manera podemos mantener una única referencia a nuestra plantilla. Cada vez que usemos nuestro ```x-component``` reducimos el costo de tener que crear la plantilla nuevamente. Esto nos da una mejor performance a la hora de instanciar nuestros componentes y clonar una copia de la template en cada instancia. \n\nAntes de seguir con las ventajas de la API de templates, debemos conocer la [[Shadow DOM API|web-components.Apis.shadow-dom]]\n\n![[web-components.Apis.shadow-dom]]\n\nAhora que tenemos la plantilla aislada, podemos tomar ventaja de otras APIS que la Web nos provee.\n- [[web-components.Apis.content-slot]]","n":0.064}}},{"i":24,"$":{"0":{"v":"shadow-dom","n":1},"1":{"v":"\nEsta api nos permite declarar piezas de de DOM encapsuladas y aisladas en nuestra aplicación. Junto a ellas pueden encapsular sus estilos (CSS) y usar plantillas declarativas de la [[Template API|wc.Apistemplate]]\n\nEste encapsulamiento facilita la reutilización del componente y oculta su complejidad.\n\n### Como instanciar un template component con shadow dom\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `<p>Hola desde template</p>`;\n\nclass XComponent extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nEn vez de adherir la plantilla directo al componente, creamos un ```shadowRoot``` para que utilice.\n```this.attachShadow({mode: 'open'})``` le dice al navegador que este custom element debería tener un shadow root adherido. Creando este shadow root ahora tenemos una plantilla aislada donde podemos actualizar nuestro componente. La opción ```mode``` nos permite configurar si queremos que el shadow root sea accesible desde fuera del componente.\nDesgraciadamente incluso poniendo el mode en 'closed' hay formas de mediante javascript manipular el shadow root ya que no existe un constructor privado en js aún por lo que no se debería tomar esta medida como seguridad.\nUna vez creado el shadow root, podemos adherir y comenzar a actualizar nuestra plantilla.\n\n\n\n","n":0.075}}},{"i":25,"$":{"0":{"v":"custom-elements","n":1},"1":{"v":"\nEl principio fundamental de los Web Components es la API de Custom Elements. Esta nos permite definir nuestras propias etiquetas de elementos HTML y adherirles un comportamiento. Esto podemos definirlo mediante javascript:\n\n```javascript\nclass XComponent extends HTMLElement {\n  constructor(){\n    super();\n  }\n\n  connectedCallback(){\n    this.innerHTML = 'Hello World from a Web Component!'\n  }\n}\ncustomElements.define('x-component')\n```\n\nDebemos extender una clase de la clase base [[HTMLElement|https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement]]. Llamamos al ```super()``` en el constructor donde también inicializaremos los estados y la lógica inicial del componente.\n\nEl método ```connectedCallback()``` es un método del ciclo de vida del componente, se invoca cuando el componente es creado y añadido al DOM. Es donde la lógica más pesada debería ocurrir, como el fetch de datos o la lógica de renderización.\n\nComo extendemos de la clase ```HTMLElement``` obtenemos todos sus métodos y podemos acceder por el ```this```.\n\nPor último registramos el componente en el DOM por medio de la sentencia ```customElements.define('x-component', XComponent)```\nPasamos como primer parámetro la etiqueta que vamos a utilizar y como segundo la referencia a nuestro componente.\n\nYa podríamos crear un html que importe este js y utilice el componente:\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-component></x-component>\n  <script src=\"x-component.js\"></script>\n</body>\n</html>\n```\n![Alt text](image-2.png)","n":0.074}}},{"i":26,"$":{"0":{"v":"content-slot","n":1},"1":{"v":"\nLa Content Slot API nos permite pasar contenido a la plantilla de un componente de forma declarativa. Para utilizarla, debemos estar usando la [[web-components.Apis.shadow-dom]] API con nuestras plantillas.\n\n```html\n<x-component>\n  Hello World!\n</x-component>\n```\n![Alt text](image-5.png)\n\nVemos que el componente tiene dentro el Hello World! pero no lo esta renderizando, debemos hacer unos cambios en nuestro javascript.\n\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `<p><slot></slot></p>`;\n\nclass XComponent extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nAñadimos la etiqueta ```<slot></slot>``` a nuestra plantilla, lo que hará que lo que este dentro de nuestror componente se renderice.\n![Alt text](image-4.png)\n\nLa API de Content Slot está sólo disponible si tu plantilla es inicializada con una instancia de shadow dom, como vemos en el constructor.\n\n### Named Slots - Slots Nombrados\nLa API de Slots también soporta la inserción de más de un slot por componente. Esto es útil cuando precisamos crear componentes estructurados con contenido dinámico. Por ejemplo una tarjeta de un producto.\n\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    .card{\n      padding: 12px;\n      border: 1px solid #ccc;\n    }\n    .title{\n      border-bottom: 1px solid #ccc;\n      margin-bottom: 12px;\n    }\n  </style>\n  <div class=\"card\">\n    <div class=title>\n      <slot name=\"title\"></slot>\n    </div>\n    <slot></slot>\n  </div>\n`;\n\nclass XDetailCard extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-detail-card', XDetailCard);\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-detail-card>\n    <span slot=\"title\">Hello!</span>\n    from multi slot\n  </x-detail-card>\n  <script type=\"module\" src=\"x-detail-card.js\"></script>\n</body>\n</html>\n```\n![Alt text](image-6.png)\n\nNuestro ```<span slot=\"title\">``` tiene un slot que define en que slot del componente debería renderizarse.","n":0.066}}},{"i":27,"$":{"0":{"v":"Theming","n":1},"1":{"v":"\nCon las [[web-components.styling.css-custom-properties]] podemos construir temas flexibles y fáciles de mantener.\n\n- [[web-components.theming.root-host-scope]]\n\n## Implementando un tema oscuro\nCuando implementamos temas en web components, tenemos un par de estrategias disponibles para utilizar. Podríamos utilizar una hoja de estilso separada que contiene una lista actualizada de las CSS Custom Properties para ese tema particular.\n\n```css\n:root{\n  --modal-background-color: black;\n  --modal-color: white;\n  --dropdown-background-color: black;\n  --dropdown-color: white;\n}\n...\n```\nPodríamos aplicar esta hoja cuando querramos cambiar el tema. Otra estrategia es aplicar el stilo utilizando una clase particular, cuando la clase se aplica el tema se aplica:\n```css\n:root .dark-theme{\n  --modal-background-color: black;\n  --modal-color: white;\n  --dropdown-background-color: black;\n  --dropdown-color: white;\n}\n...\n```\nCualquiera de las 2 estrategias funcionaría. Podemos llevar esto un paso más adelante construyendo temas incorporados a nuestros componentes. Para hacer esto usaremos el selector ```:host``` para aplicar distintas propiedades basadas en algún atributo de nuestro elemento host.\n\n```css\n/**\n  Si nuestro elemento host tiene el atributo dark, hacer esto\n*/\n:host([dark]) p{\n  color: #fff;\n  background: #2d2d2d;\n}\n```\n\nDe esta manera podemos usar el ```:host``` para reemplazar las CSS Custom Properties y aplicar unos estilos u otros basados en los atributos de la etiqueta.\n\nEsto nos da una penalidad menor en la performance ya que todos los estilos del componente se van a descargar aunque los estilos de ese tema no se esten usando actualmente. Esto no sucedería si sólo se descarga la hoja de estilos que corresponda al tema actual.\n\n\n\n","n":0.068}}},{"i":28,"$":{"0":{"v":"Root Host Scope","n":0.577},"1":{"v":"Nuestro componente define las [[web-components.styling.css-custom-properties]] a nivel ```:host```. También podemos establecer propiedades a nivel ```:root``` y tener un valor default en nuestro componente.\n\n```js\nconst template  = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    p {\n      color: var(--z-component-color, orange);\n      font-size: var(--z-component-font-size);\n      padding: 4px;\n    }\n  </style>\n  <p>Hola desde el Web Component</p>\n`\nclass XComponent extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nEn nuestro componente tenemos dos propiedades custom de css, aunque estas no se encuentran en el host. En vez de usar ```:host```, las usamos directamente en el elemento en el que usaran.\n\nCon CSS Custom Properties podemos definir un segundo parametro que sera el **valor por defecto** de nuestra propiedad si no se setea en el scope del padre o en el selector ```:root```.\n\n![Alt text](image-22.png)\n\nPodemos pisar editar estas variables desde el root de nuestra aplicación\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    :root{\n      --z-component-color: red;\n      --z-component-font-size: 24px;\n    }\n  </style>\n</head>\n<body>\n  <x-component>\n  </x-component>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n![Alt text](image-23.png)\n\nLos beneficios de definir las props a nivel root en vez de host es que tenemos un selector plano de todas nuestras propiedades. A diferencia de lo que pasa cuando utilizamos el ```:host```. Esto nos permite configurar el tema más fácil.","n":0.072}}},{"i":29,"$":{"0":{"v":"Styling","n":1},"1":{"v":"\nUtilizando [[web-components.styling.css-custom-properties]] y [[web-components.Apis.shadow-dom]] podemos crear temas y estilar nuestros componentes.\n\n# Estilos globales\n Uno de los puntos malos del CSS es que por default, el CSS es global. \n ```css\n h1 {\n  color: red\n }\n\n ```\n Esta regla hace que **todos** los ```h1``` sean rojos. Muchas veces solo queremos aplicar una regla a un componente o vista especifico. Para hacer esto en el pasado se utilizaban convenciones de nombres como [[BEM|https://getbem.com/introduction/]], para poder evitar que accidentalmente se pisaran estilos. Por ejemplo\n ```css\n h1.article-heading{\n  color: blue\n }\n\n h1.article-heading .article-heading--green{\n  color: green\n }\n\n ```\n De esta forma se evita que el estilo impacte en todos los h1 y solo en el que tiene la clase. Esto es mejor pero no es escalable ya que es posible que en proyectos grandes nos encontremos con colisiones en los nombres.\n\n Con Web Componenst podemos usar el Shadow DOM para simplificar como escribimos CSS. \n[[web-components.styling.css-encapsulation]]\n\nPero ¿Qué ocurre si queremos pisar los estilos del componente? Tal vez para usar un tema custom. Para esto nos van a servir las\n[[web-components.styling.css-custom-properties]]\n\nMientras que las CSS Custom Properties permiten una mejor customización del componente y los temas, todavía puede haber veces en las que necesitemos más flexibilidad y debamos activar el estilo de elementos del DOM enteros en nuestro componente\n[[web-components.styling.css-parts-api]]\n\nPor ultimo nos queda ver como estilar componentes dentro de nuestros slots [[web-components.styling.slotted-elements]]","n":0.067}}},{"i":30,"$":{"0":{"v":"Slotted Elements","n":0.707},"1":{"v":"El selector ```::slotted``` hace que estilar elementos en el slot sea relativamente facil.\n\n```html\n<x-component>\n  <button>styled with ::slotted</button>\n</x-component>\n```\n\nEl componente puede estilar en su template el slot con el selector ```::slotted```\n\n```js\nconst template  = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    ::slotted(button){\n      background-color: #2d2d2d;\n      color: white;\n      padding: 12px;\n      border: 0;\n      cursor: pointer;\n    }\n  </style>\n  <slot></slot>\n`\nclass XComponent extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\n![Alt text](image-21.png)\n\nEl selector toma como parametro otro selector para seleccionar que elemento del slot te gustaría estilar. \nEl ```::slotted``` nos puede ayudar a crear temas ya que el padre de los elementos puede sobreescribir los estilos para los hijos del slot. \nHay limitaciones para este selector, solo puede seleccionar hijos directos del componente. Si nuestro boton tuviera un span dentro, el componente no podria llegar a él por medio del ::slotted .","n":0.087}}},{"i":31,"$":{"0":{"v":"CSS Parts API","n":0.577},"1":{"v":"\nCSS Parts API nos permite exponer un elemento del DOM específico en nuestro template para que pueda ser estilado publicamente. Por defecto, cualquier elemento de nuestro componente está escudado del estilo global. Podemos customizar [[web-components.styling.css-custom-properties]] pero estás pueden ser dificiles de mantener ya que sólo reprensetan una propiedad.\n\nCSS Parts expone el elemento entero para que el consumidor pueda estilarlo como necesite.\n\n```js\nconst template  = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    button{\n      background: green;\n      color: #fff;\n      border: 0;\n      padding: 12px;\n    }\n  </style>\n  <button part=\"button-one\">one</button>\n  <button part=\"button-two\">two</button>\n  <button >three</button>\n`\nclass XComponent extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nAca tenemos un componente básico con 3 botones y algunos estilos internos. En dos de los botones esta el atributo ```part``` con un nombre unico. Este atributo permite que el boton sea accedido por consumidores con css directamente. Usamos el selector ```:part``` y el nombre del part element para accederlo\n\n```css\nx-component::part(button-one){\n  background: red;\n}\nx-component::part(button-two){\n  background: blue;\n}\n```\n![Alt text](image-20.png)\n\nCSS Parts puede hacer que el codigo sea mans mantenible y flexible a los estilos. Esto igual tiene sus desventajas, si exponemos CSS Parts, nuestros estilos pueden romperse de forma imprevisible, si entregamos componentes con un sistema de diseño esto puede otorgarle demasiada flexibilidad al consumidor.","n":0.071}}},{"i":32,"$":{"0":{"v":"CSS Encapsulation","n":0.707},"1":{"v":"\nLa encapsulación de css nos permite escribir css especifico por componente que sólo va a aplicar a esa plantilla.\n\n```js\nconst template  = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    p{\n      color: red;\n    }\n  </style>\n  <p>Hola desde template, yo soy rojo</p>\n`\nclass XComponent extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    p{\n      color: blue;\n    }\n  </style>\n</head>\n<body>\n  <p>Soy un parrafo azul</p>\n  <x-component></x-component>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n![Alt text](image-15.png)\n\nVemos que a pesar de la regla ```p{color: blue}``` que aplica a todos los p, como en nuestro componente el html y el css esta encapsulado, no se ve afectado.\n\nEn las devtools podemos ver que el navegador creo un shadow root para el componente. Esto es lo que nos provee nuestro encapsulamiento. Esto funciona para ambos lados, los estilos del componente no impactan en el resto del dom y los estilos globales no impactan en el componente.","n":0.082}}},{"i":33,"$":{"0":{"v":"CSS Custom Properties","n":0.577},"1":{"v":"\nCSS Custom Properties nos ayuda a solucionar distintos problemas. Nos permitiran definir variables dinamicas para que podamos crear un tema y estilar nuestros componentes individuales. \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    :root{\n      --primary-color: blue;\n      --heading-size: 18px;\n    }\n    h2{\n      color: var(--primary-color);\n      font-size: var(--heading-size);\n    }\n    p{\n      color: var(--primary-color);\n    }\n  </style>\n</head>\n<body>\n  <h2>Titulo estilado con CSS custom property</h2>\n  <p>Parrafo estilado con css custom property</p>\n  <x-component></x-component>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n\nEn la etiqueta style vemos las reglas de css utilizando las custom properties. El selector :root es el elemento más alto del DOM. En este ejemplo este es nuestro archivo global, con el :root podemos definir nuestras primeras CSS Custom Properties. Estas pueden tener cualquier nombre pero deben empezar con dos guiones. Para usarlas usamos ```var(--variable)```.\n\n\n# Dynamic CSS Custom Properties\nUno de los beneficios principales de estas propiedades es que son dinamicas y podemos cambiar sus valores en tiempo de ejecución con Javascript.\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    :root{\n      --primary-color: blue;\n      --heading-size: 18px;\n    }\n    h2{\n      color: var(--primary-color);\n      font-size: var(--heading-size);\n    }\n    p{\n      color: var(--primary-color);\n    }\n  </style>\n</head>\n<body>\n  <h2>Titulo estilado con CSS custom property</h2>\n  <p>Parrafo estilado con css custom property</p>\n  <button>Toggle Tema</button>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n\n```js\ndocument.querySelector('button').addEventListener('click', () => {toggleStyles()})\n\nfunction toggleStyles(){\n  const styles= getComputedStyle(document.documentElement);\n  const colorValue = styles.getPropertyValue('--primary-color');\n  if (colorValue === 'green'){\n    document.documentElement.style.setProperty('--primary-color', 'blue');\n  } else {\n    document.documentElement.style.setProperty('--primary-color', 'green');\n  }\n}\n```\n\nPodemos acceder a las variables dinamicante y cambiar de azul a verde simulando un tema de la aplicación\n\n![Alt text](image-16.png)\n![Alt text](image-17.png)\n\n## Usando :host\nPodemos apuntar nuestras CSS Custom Properties a componentes especificos utilizando el selector ```:host```\nEn el siguiente ejemplo tendremos un parrafo estilado globalmente y otro dentro de un componente con estilos por default. Los estilos globales hacen al parrafo azul mientras que el componente lo hace rojo.\n\n![](image-18.png)\n\nLo que buscamos es customizar el componente y cambiar el parrafo a verde en vez de rojo.\n\n```js\n//x-component.js\nconst template  = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    :host{\n      --color: red;\n      --font-size: 16px;\n    }\n    p{\n      color: var(--color);\n      font-size: var(--font-size);\n    }\n  </style>\n  <p>Hola desde template, yo soy rojo</p>\n`\nclass XComponent extends HTMLElement {\n  constructor(){\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\nEn el css usamos el selector ```:host``` que refiere al host element. Para nuestro componente ese sería la etiqueta ```x-component```. Con el selector ```:host``` podemos usar custom css properties en el componente. Creamos la varialbe ```--color``` y ```--size```.\nCuando utilizamos propiedades custom, podemos setearlas desde fuera del componente facilmente refiriendonos al host. Haciendo que hacer temas y customizar componentes sea más fácil.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n  <style>\n    p{\n      color: blue;\n    }\n    x-component{\n      --color: green;\n      --size: 24px;\n    }\n  </style>\n</head>\n<body>\n  <p>Soy un parrafo azul</p>\n  <x-component></x-component>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n\n![Alt text](image-19.png)","n":0.048}}},{"i":34,"$":{"0":{"v":"Lifecycle","n":1},"1":{"v":"\nEn esta sección vamos a cubrir los distintos metodos del ciclo de vida de los Web Components.\n","n":0.243}}},{"i":35,"$":{"0":{"v":"Disconnected Callback","n":0.707},"1":{"v":"El hook ```disconnectedCallback()``` se llama cuando el componente es removido del DOM. Vamos a ver el siguient ejemplo\n```js\n// x-component.js\nclass XComponent extends HTMLElement {\n  disconnectedCallback() {\n    console.log('disconnectedCallback');\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\n```js\n//index.js\nimport './x-component.js'\n\nconst toggle = document.querySelector('#toggle');\nconst main = document.querySelector('main');\n\ntoggle.addEventListener('change', (e) => {\n  if (e.target.checked) {\n    main.appendChild(document.createElement('x-component'));\n  } else {\n    main.removeChild(document.querySelector('x-component'));\n  }\n});\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <input type=\"checkbox\" id=\"toggle\">\n  <main>\n  </main>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n\nDeberías poder ver por consola cada vez que el componente se desmonta cuando se deschequea el toggle.\n\n![Alt text](image-14.png)","n":0.111}}},{"i":36,"$":{"0":{"v":"Constructor Connected Callback","n":0.577},"1":{"v":"\n```js\nclass XComponent extends HTMLElement {\n  constructor() { \n    super(); \n    } \n\n  connectedCallback() { \n    this.innerHTML = 'Hello World from a Web Component!' \n  }\n}\ncustomElements.define('x-component', XComponent)\n```\n\nEl constructor se ejecuta cada vez que una instancia del componente se crea. Sin embargo, si tenemos que instanciar al DOM o ejecutar la lógica inicial, vamos a querer correr este código en el ```connectedCallback()``` hook. Este se ejecuta cuando un componente se agrega al DOM, después de eso podemos empezar a renderizar e interactuar con el DOM.","n":0.11}}},{"i":37,"$":{"0":{"v":"Attribute Changed","n":0.707},"1":{"v":"\nEl hook ```attributeChangedCallback()``` nos notifica cada vez que un atributo en nuestro html cambia.\n\nPodemos verlo implementado en el ejemplo del [[web-components.examples.dropdown#mejoremos-nuestro-componente-con-custom-attributes]]\n\n```js\nclass XComponent extends HTMLElement {\n  static get observedAttributes() {\n    return ['name'];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'name') {\n      console.log('attrChange', name, newValue);\n    }\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-component name=\"test\"></x-component>\n  <script type=\"module\" src=\"x-component.js\"></script>\n</body>\n</html>\n```\n\nDeberíamos ver por consola el mensaje con el valor del atributo name.","n":0.118}}},{"i":38,"$":{"0":{"v":"Adopted Callback","n":0.707},"1":{"v":"\nEl hook ```adoptedCallback()``` es el menos utilizado. Se llama cuando un elemento es movido a un nuevo documento. Pasa usualmente cuando clonamos un elemento en un iframe y lo movemos al documento padre con ```Document.adoptNode()``` [[MDN Doc|https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptNode]]\n\n","n":0.164}}},{"i":39,"$":{"0":{"v":"Hierarchy and Architecture","n":0.577},"1":{"v":"\nEn esta sección vamos a desarrollar una lista de items con una vista de detalle descargada desde la [[Star Wars API|https://swapi.dev/]]. Cuando clickeamos un personaje, se nos abre su detale a la derecha.\n\n![Alt text](image-24.png)\n\nVamos a ir profundizando en buenas prácticas para la arquitectura y diseño de nuestro componente.\n\n- [[web-components.hierarchy-and-architecture.component-data-flow]]\n\n","n":0.143}}},{"i":40,"$":{"0":{"v":"Component Data Flow","n":0.577},"1":{"v":"\nCuando utilizamos componentes queremos mantenerlos genéricos y reutilizables. Para lograr esto debemos separar la lógica de fetching de datos del componente y recibir estos últimos por medio de custom properties. El flujo de datos de nuestra aplicación sería algo así:\n![Alt text](image-25.png)\nHacemos el fetch desde el main de nuestra aplicación ```index.js```, después pasamos esa data a nuestros componentes por las [[Custom Properties|web-components.communication.js-properties]]. Esta propiedada va a tener el arreglo de personajes, y esto mantiene nuestro componente de lista generico y reutilizable ya que no le importa la data que va a recibir.\n\nNuestro componente de lista también necesita comunicarse con el main para avisarle que se ha clickeado sobre un item, para eso utilizaremos un [[Custom Event|web-components.communication.events]] para indicarle al root cual fue el item seleccionado y que el pueda pasarle la data al componente de detalle.\n\nComo el de lista, a nuestro componente de detalle no le importa de donde viene la data, su unica responsabilidad es renderizarla. La idea de este patron utilizado por los principales frameworks ( Angular, Vue y React), es que la mayoría de nuestros componentes sean puros, es decir, **que su única responsabilidad sea renderizar algo**. De esta manera separamos la lógica de la renderización. Esto hace que los componentes puros sean reutilizables y más fáciles de testear con unit testing. \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <h2>Personajes de la Galaxia</h2>\n  <x-character-list></x-character-list>\n  <x-character-detail></x-character-detail>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n\n```js\n//index.js\nimport './x-character-detail.js';\nimport './x-character-list.js';\n\nconst characterListComponent = document.querySelector('x-character-list');\nconst characterDetailComponent = document.querySelector('x-character-detail');\n\ncharacterListComponent.addEventListener('characterSelected', (event) => {\n  characterDetailComponent.character = event.detail;\n})\n\nfetch('https://swapi.dev/api/people/')\n  .then(response => response.json())\n  .then(data => {\n    characterListComponent.characters = data.results;\n    characterDetailComponent.character = data.results[0];\n  })\n``` \n\nEn nuestro ```index.js``` tomamos las referencias DOM de nuestros componentes. Agregamos el ```eventListener``` para nuestro evento de la lista de componentes y cuando este se dispara, pasamos el ```detail``` del evento (donde vendra nuestro item) a nuestro componente de detalle.\n\nTambién hacemos la petición a la API para pasarle la lista de persojanes a nuestro componente lista por medio de la propiedad characters. También le damos un personaje inicial a nuestro componente de detalle.\n\n```js\n// x-character-list.js\nconst template  = document.createElement('template');\ntemplate.innerHTML = `\n  <style>\n    button{\n      display: block;\n      padding: 12px;\n      width: 100%;\n    }\n  </style>\n  <section></section>\n`\nclass XCharacterList extends HTMLElement {\n  get characters(){\n    return this._characters;\n  }\n  set characters(value){\n    this._characters = value;\n    this._render();\n  }\n  constructor(){\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n    this.characterListElement = this.shadowRoot.querySelector('section');\n  }\n\n  _render(){\n    this.characterListElement.innerHTML = '';\n    this.characters.forEach(character => {\n      const button = document.createElement('button');\n      button.innerText = character.name;\n      button.addEventListener('click', () => {\n        this.dispatchEvent(new CustomEvent('characterSelected', { detail: character }));\n      });\n      this.characterListElement.appendChild(button);\n    });\n  }\n}\n\ncustomElements.define('x-character-list', XCharacterList);\n```\nEn nuestra template definimos estilos para los botones y una seccion donde agregaremos los botones de nuestros personajes.\nEn la definición de la clase agregamos la custom property ```characters```. Tenemos sus respectivos setters y getters. El constructor hace el mismo boilerplate que venimos haciendo en nuestros otros ejemplos. Creamos una referencia a la sección que utilizaremos en el método ```_render()``` para agregar los personajes. Este método es llamado cada vez que se actualizan los personajes con el ```set```. \nDentro del render creamos el custom event para cada botón y despachamos ```characterSelected```. En otra sección hablamos de mejores opciones para manipular las templates ya que vemos que puede volverse algo muy difícil de mantener, con ayuda podremos crear templates más dinamicas y eventos de manera más sencilla.\n\n```js\n//x-character-detail.js\nclass XCharacterDetail extends HTMLElement {\n  get character(){\n    return this._character;\n  }\n  set character(value){\n    this._character = value;\n    this._render();\n  }\n  constructor(){\n    super();\n    this.attachShadow({ mode: 'open' });\n  }\n  _render(){\n    this.shadowRoot.innerHTML = `\n      <h2>${this.character.name}</h2>\n      <ul>\n        <li>Height: ${this.character.height}</li>\n        <li>Mass: ${this.character.mass}</li>\n        <li>Birth Year: ${this.character.birth_year}</li>\n      </ul>\n    `;\n  }\n}\n\ncustomElements.define('x-character-detail', XCharacterDetail);\n```\n\nEn este ejemplo estamos creando la template en el método render en vez de definirla al principio. Como este componente no debe despachar ningun evento la template es más compacta y legible.\n\nLa idea de componentes puros es un patrón común entre los distintos frameworks basados en componentes. Esto es particularmente **importante** en los Web Components ya que es probable que ellos se vayan a mezclar mucha veces con frameworks más cerrados. Mantener los componentes genericos y puros va a ser que la integración de los componentes en otras aplicaciones sea más sencilla.","n":0.039}}},{"i":41,"$":{"0":{"v":"Frameworks Integration","n":0.707},"1":{"v":"Una de las principales ventajas de adoptar Web Components es que podemos reutilizarlos a través de los distintos frameworks de JavaScript. \n\n- [[web-components.frameworks-integration.angular]]\n- [[web-components.frameworks-integration.vue]]\n- [[web-components.frameworks-integration.react]]","n":0.2}}},{"i":42,"$":{"0":{"v":"Vue","n":1},"1":{"v":"Vue es un framework de javascript más nuevo que Angular o React que recientemente ha ganado popularidad por su simpleza en su API y la facil curva de aprendizaje.\n\nEn esta sección crearemos un proyecto con VueJS Cli y agregaremos nuestro [[Dropdown|web-components.deployment.npm]] al proyecto.\n\nUsaremos la herramienta de Vue CLI para generar el proyecto. Nos proveera todas las herramientas necesarias para generar el buildeo y correr nuestra aplicación. \n\n```bash\nnpm install -g @vue/cli\nvue create my-app\n```\n\nEste comando creara nuestro proyecto e instalara las dependencias. Procedemos a instalar nuestro componente\n\n```bash\nnpm install web-component-essentials --save\n```\n\nAhora podemos importarlo en nuestro ```main.js``` de la aplicación de Vue.\n\n```js\nimport Vue from 'vue'\nimport App from './App.vue'\nimport 'web-component-essentials'\n\nVue.config.productionTip = false;\nnew Vue({\n  render: h => h(App)\n}).$mount('#app')\n```\n\nPara correr la aplicación corremos\n```bash\nnpm run serve\n```\nEsto iniciará nuestra aplicación en ```localhost:8080```. Vamos a ver nuestro componente ```HelloWorld.vue```. Vue organiza todo en un sólo archivo (los estilos, el template y el script).\n```html\n//HelloWorld.vue\n<template>\n  <div>\n    <h1>VueJS Application using Web Components</h1>\n    <p>{{show ? 'open': 'closed'}}</p>\n    <x-dropdown :title=\"myTitle\" @show=\"log\">\n      Hello from Web Component in Vue\n    </x-dropdown>\n  </div>\n</template>\n<script>\n  export default {\n    name: 'HelloWorld',\n    data: function (){\n      return {\n        myTitle: 'project-vue',\n        show: false\n      }\n    },\n    methods:{\n      log: function (event){\n        console.log(event);\n        this.show = event.detail;\n      }\n    }\n  }\n</script>\n```\n\nEn nuestra ```template``` tenemos una sintaxis similar a [[web-components.frameworks-integration.angular]], podemos ver la expresión ```{{show ? 'open' : 'closed'}}```. En el Dropdown estamos usando la sintaxis de bindeo de Vue, esta sintaxis funciona bien con todos los HTML elements asi como tambien custom elements usando Web Components.\n\nPara bindear una propiedad en vue usamos el ```:``` en este caso ```:title=\"myTitle\"```. Nuestro componente Vue tiene una propiedad ```myTitle``` que se le asigna al ```title``` del dropdown.\nPara escuchar eventos, usamos el ```@```, en este caso escuchamos nuestro evento show con ```@show=\"log\"```.\n\nEn el ```script``` definimos la data y los metodos de nuestro componente que vamos a querer bindear en el template.\n\nVue es una muy buena opción liviana para crear aplicaciones JS que funcionen bien con Web Components.","n":0.057}}},{"i":43,"$":{"0":{"v":"React","n":1},"1":{"v":"Vamos a ver como podemos integrar un Web Component en una librería de componentes de React.\n\nReact es la librería de js hecha por Facebook para que los desarrolladores puedan componer UIs con componentes. Fue la primer librería / framework en popularizar la arquitectura de componentes. Fue creado incluso antes de que se estandarizaran las APIs de Web Components. Por lo tanto no tiene un gran soporte de los Web Components como si los tienen la mayoría de los otros frameworks.\n\n## Compatibilidad\n\nReact usa un mecanismo de comunicación similar para la comunicación entre los componentes pasando propiedades y funciones como eventos. Desgraciadamente, el sistema de eventos de React es un sistema procesado que no utiliza los eventos nativos el anvegador. Esto significa que los eventos de los Web Components no pueden comunicarse con los componentes de React. React y la sintaxis de tempaltes JSX tratan todas las propiedades de los custom elements como atributos de manera incorrecta, forzando a los usuarios a usar valores de tipo string.\n\nPara superar estos bloqueos en nuestro ejemplo, vamos a crear componentes wrapper que envuelvan a nuestros Web Components. Esto permitira que React sea compatible con nuestros Web Components.\n\n### Create React App\nVamos a usar la CLI de Create React App para crear la aplicación\n```bash\nnpx create-react-app my-app\ncd my-app\nnpm start\n```\n\nUna vez creada, instalamos nuestro componente\n```bash\nnpm install web-component-essentials --save\n```\nAhora debemos crear en nuestra aplicación, un React Dropdown que envuelva nuestro x-dropdown\n```jsx\nimport React, {Component} from 'react';\nimport 'web-component-essentials'\n\nexport class Dropdown extends Component{\n  render(){\n    return(\n      <x-dropdown>\n        {this.props.children}\n      </x-dropdown>\n    )\n  }\n}\n```\nImportamos nuestro paquete en ```Dropdown.jsx``` y en la función render agregamos ```{this.props.children}``` para pasar los hijos elementos a nuestro slot.\n\n## Propiedades y Eventos\n\nNecesitamos mapear las propiedades y eventos del Web Component a nuestra versión de react. Para eso utilizaremos el hook ```componentDidMount()```\n\n```jsx\nimport React, {Component} from 'react';\nimport 'web-component-essentials'\n\nexport class Dropdown extends Component{\n  constructor(props){\n    super(props)\n    this.dropdownRef = React.createRef();\n  }\n  componentDidMount(){\n    this.dropdownRef.current.title = this.props.title;\n    if (this.props.onShow){\n      this.dropdownRef.current.addEventListener('show', (e) => this.props.onShow(e))\n    }\n  }\n\n  render(){\n    return (\n      <x-dropdown ref={this.dropdownRef}>\n        {this.props.children}\n      </x-dropdown>\n    )\n  }\n}\n```\n\nUsando la Refs API podemos tomar la referencia a nuestro x-dropdown. con esta referencia podemos crear un ```eventListener```, en él podemos usar la función que pasemos en nuestra ```onShow``` prop de nuestro react component. Esto permitirá que el Web Component se comunique con otros componentes de React. También asignamso el ```title``` a nuestro componente React para pasarlo a nuestra propiedad del web component.\n\n## Actualizar props\n\nNecesitamos agregar codigo adicional para que cuando nuestras propiedades del React component cambien, esto impacte en nuestro dropdown. Para esto agregamos el hook ```componentDidUpdate()```\n\n```jsx\nimport React, {Component} from 'react';\nimport 'web-component-essentials'\n\nexport class Dropdown extends Component{\n  constructor(props){\n    super(props)\n    this.dropdownRef = React.createRef();\n  }\n  componentDidMount(){\n    this.dropdownRef.current.title = this.props.title;\n    if (this.props.onShow){\n      this.dropdownRef.current.addEventListener('show', (e) => this.props.onShow(e))\n    }\n  }\n\n  componentDidUpdate(prevProps){\n    if (this.props.title !== prevProps.title){\n      this.dropdownRef.current.title = this.props.title\n    }\n    if (this.props.show !== prevProps.show){\n      this.dropdownRef.current.show = this.props.show\n    }\n  }\n\n  render(){\n    return (\n      <x-dropdown ref={this.dropdownRef}>\n        {this.props.children}\n      </x-dropdown>\n    )\n  }\n}\n```\nUsando el hook ```componentDidUpdate()``` podemos reaccionar cuando se actualizan las propiedades y actualizar nuestro Web Component.\n\nAhora tenemos todas las funcionalidades de nuestro web component andando y comunicandose con otros componentes de react.","n":0.045}}},{"i":44,"$":{"0":{"v":"Angular","n":1},"1":{"v":"\nAngular fue diseñado desde el principio para funcionar con Web Components. Puede consumir Web Components y publicar los componentes de Angular como Web Components por medio de la API Angular Elements. Vamos a instalar nuestro [[Dropdown|web-components.deployment.npm]] en un proyecto de Angular CLI.\n\nPrimero creamos el proyecto angular\n\n```bash\nnpm install -g @angular/cli\nng new my-app\n```\nEste comando instalar angular, creara un proyecto e instalara todos los paquetes NPM necesarios. Una vez completado utilizaremos\n```bash\nng serve\n```\nQue iniciará nuestra aplicación en ```localhost:4200```. Ahora debemos instalar nuestro componente, en [[Deploy con npm|web-components.deployment.npm]] utilizamos un CDN, aqui lo instalaremos directamente con npm:\n\n```bash\nnpm install web-component-essentials\n```\n\nEste componente instalara el dropdown en nuestro proyecto de Angular. En nuestro ```app.module.ts``` podemos importarlo\n\n```ts\n//app.module.ts\nimport {BrowserModule} from '@angular/platform-browser';\nimport {NgModule, CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';\nimport 'web-component-essentials';\nimport {AppComponent} from './app.component';\n\n@NgModule({\n  declarations:[\n    AppComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n  schemas:[\n    CUSTOM_ELEMENTS_SCHEMA // Le avisa a Angular que tenemos custom tags\n  ]\n})\n\nexport class AppModule {\n\n}\n```\nUna vez instalado podemos utilizarlo, vamos a mirar nuestro ```app.component.ts```\n\n```ts\n//app.component.ts\nimport {Component} from '@angular/core'\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent{\n  myTitle = 'project-angular';\n  open = false;\n\n  toggle(event){\n    console.log(event);\n    this.open = event.detail;\n  }\n}\n```\n\nEste componente es el root de nuesta aplicación Angular. En nuestro componente, tenemos 2 propiedades: el ```myTitle``` lo pasaremos al dropdown y la propiedad ```open``` observara si el dropdwon esta abierto o cerrado.\nTambién tenemos un metodo ```toggle()``` que se llamará cada vez que el dropdown se abre o cierra.\n\n```html\n<!-- app.component.html -->\n<h1>Angular Application using Web Components</h1>\n<p>\n  {{open ? 'open':'closed'}}\n</p>\n<x-dropdown [title]='myTitle' (show)=\"toggle($event)\">\n    Hello from Web Component in Angular!\n</x-dropdown>\n```\n\nTenemos un p que muestra el mensaje ```open``` o ```closed``` basado en el valor de la propiedad open. Esta sintaxis no funciona solo para Angular sino también para los Web Components\n\nEl primer bindeo es la propiedad ```[title]=\"myTitle\"``` para avisarle a Angular que esa propiedad debería ser seteada. La segunda sintaxis es la que utiliza Angular para escuchar eventos ```(show)=\"toggle($event)\"```. En el parentesis pasamos el nombre del evento que queremos escuchar, y a la derecha el metodo.\n\nAngular es una excelente opción para aplicaciones del lado del cliente por su robusta API que funciona bien con aplicaciones de grandes empresas mientras mantiene el soporte de Web Components.","n":0.054}}},{"i":45,"$":{"0":{"v":"Deployment","n":1},"1":{"v":"\nPara que nuestros componentes sean utiles tenemos que poder publicarlos de forma sencilla para que otros los puedan usar y después agregar complejidad para cubrir más casos de usos.\n\n- [[web-components.deployment.npm]]\n- [[web-components.deployment.browser-support]]","n":0.18}}},{"i":46,"$":{"0":{"v":"Npm","n":1},"1":{"v":"Para este ejemplo vamos a dar por sentado algunas cosas sobre cómo nuestro componente debería ser usado.\n\n- Soporta sólo navegadores que soporten el core de Web Components API.\n- Los consumidores de nuestro componente usan NPM\n\nEn nuestor ejemplo tendremos una estructura de carpetas así\n![](image-26.png)\n\nEn nuestro ```dropdown.js``` tenemos el componente que construimos en [[web-components.examples.dropdown]]. En ```index.js``` exportamos el componente y cualquier otro componente que haya en nuestra librería.\n\nPara publicar a NPM primero necesitamos crear nuestro ```package.json``` el cual define la metadata de nuestro paquete así como las otras dependencias que podríamos estar utilizando de otros paquetes NPM. \n\nPara crear nuestro ```package.json``` debemos tener instalado NodeJS. Una vez realizado, la CLI de NPM nos va a permitir crearlo con\n\n```bash\nnpm init\n```\n\nEsto nos abrirá un prompt para completar la configuración básica de nuestro proyecto\n\n```json\n{\n  \"name\": \"web-componet\",\n  \"version\": \"0.0.1\",\n  \"description\": \" Esto es un web component \",\n  \"main\": \"src/index.js\",\n  \"module\": \"src/index.js\",\n  \"directories\":{\n    \"src\": \"src\"\n  },\n  \"author\": \"El autor\",\n  \"license\": \"La licencia que corresponda\"\n}\n```\n\nUtilizamos las propiedades ```main``` y ```module``` para ayudar a los bundlers como Webpack a entender como consumir nuestro paquete y donde se encuentra el entry point de la librería. \n\nAhora que ya tenemos la configuración mínima, podemos publicarlo con\n\n```bash\nnpm publish\n```\n\nAsumiendo que tenemos un acuenta de NPM y estamos logeados, nuestro componente debería publicarse correctamente en el registro de NPM. \n\nPara utilizarlo en otro proyecto tenemos un par de opciones. Normalmente tendríamos un bundler como Webpack para realizar el build, pero para esta demo, lo mantendremos simple con una etiqueta script en un HTML. \n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-dropdown>\n    Hola mundo desde componente publicado\n  </x-dropdown>\n  <script type=\"module\" src=\"https://unpkg.com/web-component-essentials@0.0.1/src/dropdown.js\"></script>\n</body>\n</html>\n```\nUtilizamos [[unpkg.com|https://unpkg.com/]] CDN para publicar nuestro componente sin pasos de buildeo facilmente. ","n":0.06}}},{"i":47,"$":{"0":{"v":"Browser Support","n":0.707},"1":{"v":"Los Web Components no son soportados en todos los navegadores, en IE11 se necesita compilar a ES5 y utilizar polyfills.\n\nHay 2 desafios al utilizar Web Components en navegadores que todavia no los soportan. El primero es la falta de soporte de JavaScript ES2015. Los navegadores más antiugos como IE no soportan las ultimas características de JavaScript como las clases de las cuales los custom elements dependen.\nPara lograr este soporte debemos agregar un paso a nuestro buildeo para transpilar nuestro codigo. Esto es similar a compilar, tomamos el codigo ES2015 y lo convertimos en codigo de ES5 que todos los navegadores soportan.\n\nLas 2 formas más comunes de transpilar el codigo de ES2015 a ES5 es utilizando Bable y Typescript. Typescript tiene un soporte de transpilación similar a Bable y agrega tipado statico a nuestro js, haciendolo más mantenible y testeable. En este ejemplo utilizaremos vanilla javascript y babel.\n\n## Polyfills\n\nMientras que casi todos los navegadores soportan ES2015, no todos soportan las APIS de Web Components. Afortunadamente podemos usar polifyll para crear Web Components y mantener un soporte entre los navegadores.\n\nVamos a usar [[Web Components Polyfills | https://github.com/webcomponents/webcomponentsjs]]. Estos Polyfills incluyen las funcionalidades esenciales de la Web API de Web Components. \nSi abrimos nuestro dropdown en un navegador que no soporta como IE, vamos a tener errores y el componente no va a tener la funcionalidad que corresponde. Vamos a modificar nuestro html para que los navegadores incompatibles lo soporten\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-dropdown>\n    Hola mundo desde componente publicado\n  </x-dropdown>\n  \n  <script type=\"module\" src=\"https://unpkg.com/@webcomponents/webcomponentsjs@2.8.0/webcomponents-bundle.js\"></script>\n  <script type=\"module\" src=\"https://unpkg.com/web-component-essentials@0.0.1/src/dropdown.js\"></script>\n</body>\n</html>\n```\n\nAhora con el ```webcomponents-bundle.js``` las features que faltaban se agregan y el componente funcionara. Esto hara que funcione en todos los navegadores modernos pero algunos todavía nos preocupamos por navegadores más antiguos como IE. Para lograr esta compatibilidad necesitaremos un paso extra. Vamos a tener que agregar a nuestra librería conteniendo el dropdown algunas herramientas para compilar el código ES2015 a ES5. Las 2 principales herramientas que usaremos en esta sección son Webpack y Babel. \nWebpack permite enpaquetar dependencias en un bundle para aplicaciones. Babel es un compilador que va a transpilar nuestro codigo a ES5.\n\n# Instalando Webpack y Babel\n\nEl primer paso es instalar webpack y babel en nuestra librería\n\n```bash\nnpm install rimraf webpack webpack-cli babel-core babel-loader babel-preset-env --save-dev\n```\n\nEsto añadirá los paquetes a nuestro ```package.json```. Este debe contar aparte con nuestras propiedades ```\"main\": \"dist/index.js``` y ```\"module\": \"src/index.js```\nEl main indicara donde se encuentra el codigo compilado en ES5. El ```module``` donde se encuentra el codigo ES2015. El JS situado en ```/dist``` sera el compilado de nuestra fuente ```/src```.\n\nTambién ebemos agregar scripts a nuestro json\n```json\n\"scripts\":{ \n  \"clean\": \"rimraf dist\",\n  \"build\": \"npm run clean && webpack --mode production\"\n}\n```\n\nEl script clean limpia la carpeta dist, el build creara el build de nuestro codigo en la carpeta dist.\n\n![[web-components.extra-tools.webpack]]\n\n\n","n":0.047}}},{"i":48,"$":{"0":{"v":"Communication","n":1},"1":{"v":"\nEn los Web Components, los slots son ideales para el contenido pero a menudo necesitamos pasar datos o configuraciones a nuestro componente. Esto podemos lograrlo mediante las **propiedades o atributos**.\n\n- [[web-components.communication.js-properties]]\n- [[web-components.communication.events]]\n- [[web-components.communication.custom-attributes]]\n\n![Alt text](image-12.png)","n":0.171}}},{"i":49,"$":{"0":{"v":"JS Properties","n":0.707},"1":{"v":"\nCon las props podemos pasar cualquier tipo de dato de javascript a nuestro componente, incluyendo datos no primitivos como los objetos y arreglos. \n\n```js\n//x-component.js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <p></p>\n`;\n\nclass XComponent extends HTMLElement {\n  set name(value){\n    this._name = value;\n    this.nameElement.innerText = this._name;\n  }\n\n  get name(){\n    return this._name;\n  }\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n    this.nameElement = this.shadowRoot.querySelector('p');\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nGracias a ES2015 podemos utilizar getters y setters para definir propiedades en nuestro componente que, cuando se setean, pueden involucrar alguna logica. En este ejemplo tenemos un set y get ```name```. El getter devuelve el valor de ```_name```, nuestra propiedad privada para mantener el valor que se renderizará. El setter setea la variable privada ```_name``` y el texto de nuestro ```nameElement``` el cual creamos en el constructor. Cualquiera que utilice nuestro componente puede setear la variable name para ver los cambios.\n```js\n// index.js\nimport './x-component.js'\n\nconst component = document.querySelector('x-component');\ncomponent.name = 'Hello World from Prop'\n``` \n```html\n<!--index.html-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <x-component></x-component>\n  <script type=\"module\" src=\"index.js\"></script>\n</body>\n</html>\n```\n![Alt text](image-7.png)\n\nUsar propiedades es la manera principal y más recomendada para pasar data a los componentes.","n":0.075}}},{"i":50,"$":{"0":{"v":"Events","n":1},"1":{"v":"\nLos eventos proporcionan un mecanismo por el cual el componente puede notificarnjos de que algo cambio. Por ejemplo al usar un botón podemos escuchar el evento ```click``` para notificar que el usuario clickeo el botón. \n\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <button>click me!</button>\n`;\n\nclass XComponent extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n    this.shadowRoot.querySelector('button').addEventListener('click', () => {\n      console.log('clicked!')\n    });\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n![Alt text](image-8.png)\n\nAhora podemos escuchar cuando el usuario clickea pero esto es sólo una parte de la solución. Ahora debemos crear un evento custom para nuestro componente, para que cualquiera usandolo pueda hacer algo cuando nuestro boton es clickeado.\n\n```js\n//x-component.js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <button>click me!</button>\n`;\n\nclass XComponent extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n    this.shadowRoot.querySelector('button').addEventListener('click', () => {\n      this.handleClick();\n    });\n  }\n  handleClick(){\n    this.dispatchEvent(new CustomEvent('customClick', { detail: `Hola desde el evento click, ${Math.random()}` }));\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nAgregamos un nuevo método ```handleClick``` que se llamará cuando alguien haga click sobre el botón y disparará un nuevo custom event ```customClick```.\nCuando despachamos un custom event debemos proveer 2 parametros, el primero es el nombre del evento ```customClick```. Ahora cualquiera que use el componente puede escuchar el evento customClick.\nEl segundo parametro es un objeto de configuración para el evento, en él ahora tenemos una sola propiedad ```detail``` donde podemos adherir cualquier valor al evento.\nVeamos como se escucha este evento\n```js\n// index.js\nimport './x-component.js'\n\nconst component = document.querySelector('x-component');\ncomponent.addEventListener('customClick', e =>{\n  console.log(e)\n})\n```\n![Alt text](image-9.png)\n\nEstamos escuchando nuestro custom event, y ahora podemos hacer con el lo que querramos como si se tratara de cualquier evento de javascript.\nEn el evento recibimos todos los detalles del DOM sobre nuestro componente y en el detalle el valor que pasamos.","n":0.061}}},{"i":51,"$":{"0":{"v":"Custom Attributes","n":0.707},"1":{"v":"\nCuando utilizamos Web Components solemos usar los atributos HTML para pasar información al componente. \n```html\n<x-component message='hello world'></x-component>\n```\nEstamos usando un atributo custom llamado ```message```. Podemos leer el valor de los atributos desde nuestro componente. Son convenientes para pasar información sin necesidad de usar javascript. Lo malo es que siempre son tratados como strings, no podemos pasar otro tipo de datos sin un parseo adicional al string.\n\n```js\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n  <p></p>\n`;\n\nclass XComponent extends HTMLElement {\n  static get observedAttributes() {\n    return ['message'];\n  }\n  set message(value){\n    this._message = value;\n    this.messageElement.innerText = this._message;\n  };\n  get message(){\n    return this._message;\n  }\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n    this.messageElement = this.shadowRoot.querySelector('p');\n  }\n  attributeChangedCallback(attrName, oldValue, newValue) {\n    if (attrName === 'message') {\n      this.message = newValue;\n    }\n  }\n}\n\ncustomElements.define('x-component', XComponent);\n```\n\nEl metodo estatico ```observedAttributes``` espera una lista con los atributos que el DOM debe esperar que cambie. Esto es requerido para optimizar la performance de la app, y para poder recibir actualizaciones sobre que atributos cambiaron. La segunda parte de la custom Attribute API es  el metodo ```attributeChangeCallback()``` que se llama cada vez que uno de nuestros atributos listados se actualiza. El primer parametrro es el nombre del atributo que cambio, el segundo es el valor anterior y el tercero es el nuevo.","n":0.07}}}]}
